The exclusive choice between concurrency and high performance on a single core is not inherent in software development.  High performance systems languages, like C and C++, eschew garbage collectors in favor of manual memory management.  When applied to concurrent data structures this creates friction between simple, maintainable code that leaks, and code that's complex and difficult to maintain but doesn't leak.  Application programmers must choose the latter since leaking memory is generally unacceptable.  However, these languages provide little support for programmers to accomplish this, and the wheel must be reinvented with every data structure.  We introduce DEF, a programming language that provides a third option: code that is both simple and maintainable, and safely reclaims memory from concurrent data structures.  DEF is ``close to the machine'' like C, allowing programmers to performance engineer their code, but provides native support for memory reclamation using Forkscan.  Further, in the face of extensive legacy C and C++ code, DEF is designed to integrate seemlessly into existing projects, allowing programmers to apply it precisely as much as desired.

A sample benchmark that compares (leaky) C and (non-leaky) DEF concurrent data structure performance is provided.
