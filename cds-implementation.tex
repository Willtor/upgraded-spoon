
The are two classes of data-structrues chosen for our comparison, sets and priority queues each with their own benchmark driver. In the set benchmark, items are randomly added and removed at a specified update rate. For the priority queues either a random element is added or the minimum element is removed.

\paragraph{Skip List} A fixed-height lock-free skip list was included as a well-known probabilistic concurrent data structure.  Each node contains one value, and the nodes are arranged in a list with a set of one or more forward pointers.  Each forward pointer points to the next node with at least that height, and the height of all nodes have an averages two.  Operations take logarithmic time, as they would in a binary tree, but tend to have better cache usage. A node is retired by the thread that swings the lowest height pointer during the removal of a node; a one-line change to the algorithm as described in Herlihy-Shavit.\cite{HSBook}

\paragraph{Hash Table} The lock-free separate chaining hash table performed favorably in Michael's tests. \cite{HashTables} Each bucket in the hash table contains a lock-free linked list by Harris \cite{Harris}. The list at each bucket is sorted and allows for early search termination. Like the Harris list a window of nodes is kept during the \texttt{find} procedure and used in insertion and removal. Nodes in the list are removed by marking the current node's next pointer, effectively locking that node. This stops another node inserted in front of the current node being deleted. Finally the removing thread swings the previous node's next pointer to the next pointer of the current node being removed, splicing the current node out of the list. Other threads that see a marked next pointer help remove the marked node from the list, making the remove operations cooperative and lock-free.

\paragraph{Binary Tree} The fast concurrent lock-free binary search tree by Natarajan and Mittal is a recent concurrent data structure that operates by marking edges rather than nodes. \cite{LFBinaryTree} The algorithm is relative simple and fast due to the lack of any rebalancing algorithm. Rebalancing algorithms are a source of contention as some require a potentially global data-structure reorganisation. The data-structure is an external binary tree, meaning the values of the set are stored in the leaf nodes rather than throughout the tree. The internal nodes are only for routing and serve no other purpose. The work-horse of the data-structure is the \texttt{seek} method. Like the Harris linked list, \texttt{seek} constructs a window of the tree while searching. \texttt{Seek} will exclude nodes that have been marked for deletion as those nodes cannot be valid ancestors for replacement when removing. The tree contains a fixed amount of nodes which are never removed so that there will always be a valid node family tree. Removing a node is a two stage process and requires two bits. The two bits represent \textit{flagging} and \textit{tagging} of an edge. To remove a node first the thread first marks the parent's edge to the node, this mark is a flagging operation. The second marking takes place in the \texttt{cleanup} method, \texttt{cleanup} is run when a modifying operation sees a \textit{flagged} edge to a node. The second marking is done on the sibling node of the node to be removed, this marking is called \textit{tagging}. Once both edges (of the parent) have been marked no other modifying operation can occur and now the parent and the node to be removed can be unlinked. Like deletion, retiring is a two stage process. The thread that initially injects the deletion, via \textit{flagging} an edge, retires the leaf node. Later the thread that replaces the successor in \texttt{cleanup} with the sibling of the to be deleted node retires the successor node.


\paragraph{Shavit Lotan Queue} This was included as an example of a skip list-based priority queue. \cite{ShavitLotanQueue} The Shavit Lotan Queue is a lock-free priority queue data-structure where the \texttt{pop-min} method traverses the lowest height/level of the skip list. Since the skip list is a series of sorted linked lists, with the lowest height/level containing all values, threads can remove the top items from the list which have the highest priority. Deletion is done logically, using the atomic swap (or similar CAS) to mark a node as deleted and then physically removing that node at that point or sometime after. Timestamps can be added to each node in order to make the list linearisable \cite{Linearizability}, otherwise the structure is quiescently consistent (cite). As in the skip list, the node is retired by the thread that swings its lowest height pointer.

\paragraph{SprayList} Finally, the SprayList priority queue was implemented. \cite{SprayList} Like the other priority queue, this is based on a skip list, but the node to remove is selected probabilistically from near the beginning to reduce contention. This probabilistic walk is refered to as the \textit{spray} and is paramount to reducing contention from threads. The SprayList is a relaxed concurrent data-structure whereby \texttt{pop-min} will remove from a range of top items in the list. The range and other parameters of the \textit{spray} are initialised by the number of expected threads (concurrency) acting on the queue. Because nodes closer to the beginning are less likely to be \textit{landed-on} after the \textit{spray}, padding nodes are added to the beginning of the list. Once the SprayList \textit{sprays} it will continue in the same fashion as the Shavit Lotan Queue and traverse the lowest level of the list until a deleted node is found. Under high contention the SprayList can scale significantly better than other concurrent priority queues. As in the skip list, the node is retired by the thread that swings its lowest height pointer.