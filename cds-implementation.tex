
The structures selected are all sets, and the main benchmark driver randomly adds and removes nodes from them at a specified update rate.  It also includes two priority queues with their own driver.

\paragraph{Skip List} A fixed-height lock-free skip list was included as a well-known probabilistic concurrent data structure.  Each node contains one value, and the nodes are arranged in a list with a set of one or more forward pointers.  Each forward pointer points to the next node with at least that height, and the height averages two.  Operations take logarithmic time, as they would in a binary tree, but tend to have better cache usage.  A node is retired by the thread that swings the lowest height pointer during removal; a one-line change to the algorithm as described in Herlihy-Shavit.\cite{HSBook}

\paragraph{Hash Table} The lock-free separate chaining hash table performed favorably in Michael's tests.\cite{HashTables} Each bucket in the hash table contains a lock-free linked list based on the (Harris/Fraser list). The list at each bucket is sorted and allows for early search termination. Like the Harris list a window of nodes is kept for insertion and removal. Nodes in the list are removed by marking the current node's next pointer, effectively locking that node, then swinging the previous node's next pointer to the next pointer of the current node being removed. This stops another node inserted in front of the current node being deleted. Other threads which see a marked next pointer help remove the makred node from the list, making the remove operations cooperative and lock-free.

\paragraph{Binary Tree} The fast concurrent lock-free binary search tree by Natarajan and Mittal is a recent concurrent data structure that operates by marking edges rather than nodes.\cite{LFBinaryTree} The algorithm is relative simple and fast due to the lack of an active rebalancing algorithm. Rebalancing algorithms are a source of contention as some require a potentially global data-structure reorganisation. The data-structure is also an external binary tree, meaning the values of the set are stored in the leaf nodes rather than throghout the tree. The internal nodes are only for routing and serve no other purpose. The work-horse of the data-structure is the \texttt{seek} method. Like the Harris linked list, \texttt{seek} constructs a window of the tree while searching. \texttt{Seek} will exclude nodes that have been marked for deletion as those nodes cannot be valid ancestors when removing. The tree contains nodes which are never removed so that there will always be a valid node family tree. Removing a node is a two stage process, first the node has its parent's edge to it marked and then marking the egde of the node's sibling and successor. Once both edges (of the parent) have been marked no other modifying operations can occur and the parent (an internal routing node) and the node to be removed can be removed. (talk about retiring)

\paragraph{Shavit Lotan Queue} This was included as an example of a skip list-based priority queue.\cite{ShavitLotanQueue} The Shavit Lotan Queue is a lock-free priority queue data-structure where the \texttt{pop-min} method traverses the lowest level of the skip list. Since the skip list is a series of sorted linked lists, with the lowest level containing all values, threads can remove the top items from the list which have the highest priority. Deletion is done via logically, using the atomic swap (other similar CAS) to mark a node as deleted and then physically removing that node then or sometime after. Timestamps can be added to each node in order to make the list linearisable (cite), otherwise the structure is quiescently consistent (cite).

\paragraph{SprayList} Finally, the SprayList priority queue was implemented.\cite{SprayList}  Like the other, this is based on a skip list, but the node to remove is selected probabilistically from near the beginning to reduce contention. This probabilistic walk is refered to as the \textit{spray} and is paramount to reducing contention from threads. The SprayList is a relaxed concurrent data-structure whereby \texttt{pop-min} will remove from a range of top items in the list. The range and other parameters of the spray are initialised by the number of expected threads (concurrency) acting on the list. Because nodes closer to the beginning are less likely to be \textit{landed-on} after the spray padding nodes are added to the beginning of the list. Once the SprayList sprays it will continue in the same fashion as the Shavit Lotan Queue and traverse the lowest level of the list until a non-deleted node is found. Under high contention the SprayList can scale significantly better than other concurrent priority queues. As in the skip list, the node is retired by the thread that swings its lowest height pointer. 
