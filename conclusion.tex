DEF plugs memory leaks in high-performance concurrent data structures.  Code is close to the machine, enabling a programmer to performance engineer the code.  Languages that are close to the machine have hung on and thrived because applications demand the flexibility they provide.  It's rare for a new systems language to offer this kind of support, instead favoring a model that works well in the general case.  But DEF provides tools for fine-tuning and optimizing.  Benchmark tests demonstrate that it competes favorably with C, both in single thread execution, and in scalability experiments.  And it does it with a cleaner, more readable syntax.

DEF's modularity comes from the \texttt{retire} memory reclamation keyword that allows the system to track memory only when it becomes absolutely necessary.  Tracking memory from the point of allocation, and interfering with read performance by adding write instructions are both intolerable for some applications.  In implementation, retiring usually performs within a small margin of leaky, except in extremely remove-heavy workloads where Forkscan gets overwhelmed and throttles.  In design, retiring allows a module to remain self-contained such that the caller is not restricted about where pointers may be kept or for how long, and it imposes no dependency on choice of allocator or where memory comes from (except that it must all come from the same place).

Finally, DEF is compatible with C in that it includes functionality for generating header files from DEF source files and can even include header files directly in DEF code.  It doesn't add runtimes apart from what it requires for parallelism and concurrency, making its footprint light and reducing the likelihood of conflict.  Compatibility means not just that DEF can be incorporated into legacy C applications, but even non-C applications that would otherwise incorporate C code.

The sum total of these design criteria is that DEF fits a niche not addressed by other programming languages.  And the niche is not small -- it's growing along with demand for high-performance concurrency.  The hardware that needs such a language is already commercially available; the machine on which we tested has 72 cores on four sockets.  DEF is for concurrency.

\subsection{Future Work}

Linguistically, DEF's C interface needs to be extended to macros.  Hooking into other languages often requires the use of such macros.  Expressions and some statements will be easy to convert.  Others, not so much, especially where they use unbalanced scopes.  Some investigation into how common this kind of programming practice is will determine the level of effort.

DEF's rudimentary support for hardware transactions needs to be extended to fast hybrid transactions to guarantee forward progress.  Integrating transactions with memory reclamation is non-trivial, particularly as implemented by Forkscan, since transactions writing to copy-on-write pages created during the snapshot automatically abort without performing the copy.

The compiler only works on Linux, in large part because Forkscan only works on Linux.  Forkscan either needs to be ported, or an alternative needs to be found or designed for Windows that meets the same restrictions for the sake of modularity.

Beyond the language, itself, DEF presents an opportunity to experiment with concurrent data structures operating in real applications.  The source code for many scientific computing applications is publicly available, and there is opportunity for augmenting and testing them with DEF modules.
